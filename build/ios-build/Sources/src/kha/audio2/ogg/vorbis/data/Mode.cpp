// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_haxe_io_Input
#include <haxe/io/Input.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_VorbisDecodeState
#include <kha/audio2/ogg/vorbis/VorbisDecodeState.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_Mode
#include <kha/audio2/ogg/vorbis/data/Mode.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_ReaderError
#include <kha/audio2/ogg/vorbis/data/ReaderError.h>
#endif
#ifndef INCLUDED_kha_audio2_ogg_vorbis_data_ReaderErrorType
#include <kha/audio2/ogg/vorbis/data/ReaderErrorType.h>
#endif

namespace kha{
namespace audio2{
namespace ogg{
namespace vorbis{
namespace data{

void Mode_obj::__construct(){
            	HX_STACK_FRAME("kha.audio2.ogg.vorbis.data.Mode","new",0x0813d4a5,"kha.audio2.ogg.vorbis.data.Mode.new","kha/audio2/ogg/vorbis/data/Mode.hx",12,0x8e3dac8a)
            	HX_STACK_THIS(this)
            	}

Dynamic Mode_obj::__CreateEmpty() { return new Mode_obj; }

hx::ObjectPtr< Mode_obj > Mode_obj::__new()
{
	hx::ObjectPtr< Mode_obj > _hx_result = new Mode_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic Mode_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Mode_obj > _hx_result = new Mode_obj();
	_hx_result->__construct();
	return _hx_result;
}

 ::kha::audio2::ogg::vorbis::data::Mode Mode_obj::read( ::kha::audio2::ogg::vorbis::VorbisDecodeState decodeState){
            	HX_STACK_FRAME("kha.audio2.ogg.vorbis.data.Mode","read",0x0beb0371,"kha.audio2.ogg.vorbis.data.Mode.read","kha/audio2/ogg/vorbis/data/Mode.hx",15,0x8e3dac8a)
            	HX_STACK_ARG(decodeState,"decodeState")
HXLINE(  16)		HX_VARI(  ::kha::audio2::ogg::vorbis::data::Mode,m) =  ::kha::audio2::ogg::vorbis::data::Mode_obj::__new();
HXLINE(  17)		Int _hx_tmp;
HXDLIN(  17)		Bool _hx_tmp1 = (decodeState->validBits < (int)0);
HXDLIN(  17)		if (_hx_tmp1) {
HXLINE(  17)			_hx_tmp = (int)0;
            		}
            		else {
HXLINE(  17)			Bool _hx_tmp2 = (decodeState->validBits < (int)1);
HXDLIN(  17)			if (_hx_tmp2) {
HXLINE(  17)				Bool _hx_tmp3 = (decodeState->validBits == (int)0);
HXDLIN(  17)				if (_hx_tmp3) {
HXLINE(  17)					decodeState->acc = (int)0;
            				}
HXDLIN(  17)				while(true){
HXLINE(  17)					Bool _hx_tmp4;
HXDLIN(  17)					Bool _hx_tmp5 = (decodeState->bytesInSeg == (int)0);
HXDLIN(  17)					if (_hx_tmp5) {
HXLINE(  17)						Bool _hx_tmp6 = !(decodeState->lastSeg);
HXDLIN(  17)						if (_hx_tmp6) {
HXLINE(  17)							Int _hx_tmp7 = decodeState->next();
HXDLIN(  17)							_hx_tmp4 = (_hx_tmp7 == (int)0);
            						}
            						else {
HXLINE(  17)							_hx_tmp4 = true;
            						}
            					}
            					else {
HXLINE(  17)						_hx_tmp4 = false;
            					}
HXDLIN(  17)					if (_hx_tmp4) {
HXLINE(  17)						decodeState->validBits = (int)-1;
HXDLIN(  17)						goto _hx_goto_0;
            					}
            					else {
HXLINE(  17)						decodeState->bytesInSeg--;
HXDLIN(  17)						Int a = decodeState->acc;
HXDLIN(  17)						hx::AddEq(decodeState->inputPosition,(int)1);
HXDLIN(  17)						Int _hx_tmp8 = decodeState->input->readByte();
HXDLIN(  17)						Int _hx_tmp9 = (a + ((int)_hx_tmp8 << (int)decodeState->validBits));
HXDLIN(  17)						decodeState->acc = _hx_tmp9;
HXDLIN(  17)						hx::AddEq(decodeState->validBits,(int)8);
            					}
HXDLIN(  17)					if (!((decodeState->validBits < (int)1))) {
HXLINE(  17)						goto _hx_goto_0;
            					}
            				}
            				_hx_goto_0:;
HXDLIN(  17)				Bool _hx_tmp10 = (decodeState->validBits < (int)0);
HXDLIN(  17)				if (_hx_tmp10) {
HXLINE(  17)					_hx_tmp = (int)0;
            				}
            				else {
HXLINE(  17)					HX_VARI( Int,z) = ((int)decodeState->acc & (int)(int)1);
HXDLIN(  17)					Int _hx_tmp11 = hx::UShr(decodeState->acc,(int)1);
HXDLIN(  17)					decodeState->acc = _hx_tmp11;
HXDLIN(  17)					hx::SubEq(decodeState->validBits,(int)1);
HXDLIN(  17)					_hx_tmp = z;
            				}
            			}
            			else {
HXLINE(  17)				HX_VARI_NAME( Int,z1,"z") = ((int)decodeState->acc & (int)(int)1);
HXDLIN(  17)				Int _hx_tmp12 = hx::UShr(decodeState->acc,(int)1);
HXDLIN(  17)				decodeState->acc = _hx_tmp12;
HXDLIN(  17)				hx::SubEq(decodeState->validBits,(int)1);
HXDLIN(  17)				_hx_tmp = z1;
            			}
            		}
HXDLIN(  17)		m->blockflag = (_hx_tmp != (int)0);
HXLINE(  18)		Int _hx_tmp13;
HXDLIN(  18)		Bool _hx_tmp14 = (decodeState->validBits < (int)0);
HXDLIN(  18)		if (_hx_tmp14) {
HXLINE(  18)			_hx_tmp13 = (int)0;
            		}
            		else {
HXLINE(  18)			Bool _hx_tmp15 = (decodeState->validBits < (int)16);
HXDLIN(  18)			if (_hx_tmp15) {
HXLINE(  18)				Bool _hx_tmp16 = (decodeState->validBits == (int)0);
HXDLIN(  18)				if (_hx_tmp16) {
HXLINE(  18)					decodeState->acc = (int)0;
            				}
HXDLIN(  18)				while(true){
HXLINE(  18)					Bool _hx_tmp17;
HXDLIN(  18)					Bool _hx_tmp18 = (decodeState->bytesInSeg == (int)0);
HXDLIN(  18)					if (_hx_tmp18) {
HXLINE(  18)						Bool _hx_tmp19 = !(decodeState->lastSeg);
HXDLIN(  18)						if (_hx_tmp19) {
HXLINE(  18)							Int _hx_tmp20 = decodeState->next();
HXDLIN(  18)							_hx_tmp17 = (_hx_tmp20 == (int)0);
            						}
            						else {
HXLINE(  18)							_hx_tmp17 = true;
            						}
            					}
            					else {
HXLINE(  18)						_hx_tmp17 = false;
            					}
HXDLIN(  18)					if (_hx_tmp17) {
HXLINE(  18)						decodeState->validBits = (int)-1;
HXDLIN(  18)						goto _hx_goto_1;
            					}
            					else {
HXLINE(  18)						decodeState->bytesInSeg--;
HXDLIN(  18)						Int a1 = decodeState->acc;
HXDLIN(  18)						hx::AddEq(decodeState->inputPosition,(int)1);
HXDLIN(  18)						Int _hx_tmp21 = decodeState->input->readByte();
HXDLIN(  18)						Int _hx_tmp22 = (a1 + ((int)_hx_tmp21 << (int)decodeState->validBits));
HXDLIN(  18)						decodeState->acc = _hx_tmp22;
HXDLIN(  18)						hx::AddEq(decodeState->validBits,(int)8);
            					}
HXDLIN(  18)					if (!((decodeState->validBits < (int)16))) {
HXLINE(  18)						goto _hx_goto_1;
            					}
            				}
            				_hx_goto_1:;
HXDLIN(  18)				Bool _hx_tmp23 = (decodeState->validBits < (int)0);
HXDLIN(  18)				if (_hx_tmp23) {
HXLINE(  18)					_hx_tmp13 = (int)0;
            				}
            				else {
HXLINE(  18)					HX_VARI_NAME( Int,z2,"z") = ((int)decodeState->acc & (int)(int)65535);
HXDLIN(  18)					Int _hx_tmp24 = hx::UShr(decodeState->acc,(int)16);
HXDLIN(  18)					decodeState->acc = _hx_tmp24;
HXDLIN(  18)					hx::SubEq(decodeState->validBits,(int)16);
HXDLIN(  18)					_hx_tmp13 = z2;
            				}
            			}
            			else {
HXLINE(  18)				HX_VARI_NAME( Int,z3,"z") = ((int)decodeState->acc & (int)(int)65535);
HXDLIN(  18)				Int _hx_tmp25 = hx::UShr(decodeState->acc,(int)16);
HXDLIN(  18)				decodeState->acc = _hx_tmp25;
HXDLIN(  18)				hx::SubEq(decodeState->validBits,(int)16);
HXDLIN(  18)				_hx_tmp13 = z3;
            			}
            		}
HXDLIN(  18)		m->windowtype = _hx_tmp13;
HXLINE(  19)		Int _hx_tmp26;
HXDLIN(  19)		Bool _hx_tmp27 = (decodeState->validBits < (int)0);
HXDLIN(  19)		if (_hx_tmp27) {
HXLINE(  19)			_hx_tmp26 = (int)0;
            		}
            		else {
HXLINE(  19)			Bool _hx_tmp28 = (decodeState->validBits < (int)16);
HXDLIN(  19)			if (_hx_tmp28) {
HXLINE(  19)				Bool _hx_tmp29 = (decodeState->validBits == (int)0);
HXDLIN(  19)				if (_hx_tmp29) {
HXLINE(  19)					decodeState->acc = (int)0;
            				}
HXDLIN(  19)				while(true){
HXLINE(  19)					Bool _hx_tmp30;
HXDLIN(  19)					Bool _hx_tmp31 = (decodeState->bytesInSeg == (int)0);
HXDLIN(  19)					if (_hx_tmp31) {
HXLINE(  19)						Bool _hx_tmp32 = !(decodeState->lastSeg);
HXDLIN(  19)						if (_hx_tmp32) {
HXLINE(  19)							Int _hx_tmp33 = decodeState->next();
HXDLIN(  19)							_hx_tmp30 = (_hx_tmp33 == (int)0);
            						}
            						else {
HXLINE(  19)							_hx_tmp30 = true;
            						}
            					}
            					else {
HXLINE(  19)						_hx_tmp30 = false;
            					}
HXDLIN(  19)					if (_hx_tmp30) {
HXLINE(  19)						decodeState->validBits = (int)-1;
HXDLIN(  19)						goto _hx_goto_2;
            					}
            					else {
HXLINE(  19)						decodeState->bytesInSeg--;
HXDLIN(  19)						Int a2 = decodeState->acc;
HXDLIN(  19)						hx::AddEq(decodeState->inputPosition,(int)1);
HXDLIN(  19)						Int _hx_tmp34 = decodeState->input->readByte();
HXDLIN(  19)						Int _hx_tmp35 = (a2 + ((int)_hx_tmp34 << (int)decodeState->validBits));
HXDLIN(  19)						decodeState->acc = _hx_tmp35;
HXDLIN(  19)						hx::AddEq(decodeState->validBits,(int)8);
            					}
HXDLIN(  19)					if (!((decodeState->validBits < (int)16))) {
HXLINE(  19)						goto _hx_goto_2;
            					}
            				}
            				_hx_goto_2:;
HXDLIN(  19)				Bool _hx_tmp36 = (decodeState->validBits < (int)0);
HXDLIN(  19)				if (_hx_tmp36) {
HXLINE(  19)					_hx_tmp26 = (int)0;
            				}
            				else {
HXLINE(  19)					HX_VARI_NAME( Int,z4,"z") = ((int)decodeState->acc & (int)(int)65535);
HXDLIN(  19)					Int _hx_tmp37 = hx::UShr(decodeState->acc,(int)16);
HXDLIN(  19)					decodeState->acc = _hx_tmp37;
HXDLIN(  19)					hx::SubEq(decodeState->validBits,(int)16);
HXDLIN(  19)					_hx_tmp26 = z4;
            				}
            			}
            			else {
HXLINE(  19)				HX_VARI_NAME( Int,z5,"z") = ((int)decodeState->acc & (int)(int)65535);
HXDLIN(  19)				Int _hx_tmp38 = hx::UShr(decodeState->acc,(int)16);
HXDLIN(  19)				decodeState->acc = _hx_tmp38;
HXDLIN(  19)				hx::SubEq(decodeState->validBits,(int)16);
HXDLIN(  19)				_hx_tmp26 = z5;
            			}
            		}
HXDLIN(  19)		m->transformtype = _hx_tmp26;
HXLINE(  20)		Int _hx_tmp39;
HXDLIN(  20)		Bool _hx_tmp40 = (decodeState->validBits < (int)0);
HXDLIN(  20)		if (_hx_tmp40) {
HXLINE(  20)			_hx_tmp39 = (int)0;
            		}
            		else {
HXLINE(  20)			Bool _hx_tmp41 = (decodeState->validBits < (int)8);
HXDLIN(  20)			if (_hx_tmp41) {
HXLINE(  20)				Bool _hx_tmp42 = (decodeState->validBits == (int)0);
HXDLIN(  20)				if (_hx_tmp42) {
HXLINE(  20)					decodeState->acc = (int)0;
            				}
HXDLIN(  20)				while(true){
HXLINE(  20)					Bool _hx_tmp43;
HXDLIN(  20)					Bool _hx_tmp44 = (decodeState->bytesInSeg == (int)0);
HXDLIN(  20)					if (_hx_tmp44) {
HXLINE(  20)						Bool _hx_tmp45 = !(decodeState->lastSeg);
HXDLIN(  20)						if (_hx_tmp45) {
HXLINE(  20)							Int _hx_tmp46 = decodeState->next();
HXDLIN(  20)							_hx_tmp43 = (_hx_tmp46 == (int)0);
            						}
            						else {
HXLINE(  20)							_hx_tmp43 = true;
            						}
            					}
            					else {
HXLINE(  20)						_hx_tmp43 = false;
            					}
HXDLIN(  20)					if (_hx_tmp43) {
HXLINE(  20)						decodeState->validBits = (int)-1;
HXDLIN(  20)						goto _hx_goto_3;
            					}
            					else {
HXLINE(  20)						decodeState->bytesInSeg--;
HXDLIN(  20)						Int a3 = decodeState->acc;
HXDLIN(  20)						hx::AddEq(decodeState->inputPosition,(int)1);
HXDLIN(  20)						Int _hx_tmp47 = decodeState->input->readByte();
HXDLIN(  20)						Int _hx_tmp48 = (a3 + ((int)_hx_tmp47 << (int)decodeState->validBits));
HXDLIN(  20)						decodeState->acc = _hx_tmp48;
HXDLIN(  20)						hx::AddEq(decodeState->validBits,(int)8);
            					}
HXDLIN(  20)					if (!((decodeState->validBits < (int)8))) {
HXLINE(  20)						goto _hx_goto_3;
            					}
            				}
            				_hx_goto_3:;
HXDLIN(  20)				Bool _hx_tmp49 = (decodeState->validBits < (int)0);
HXDLIN(  20)				if (_hx_tmp49) {
HXLINE(  20)					_hx_tmp39 = (int)0;
            				}
            				else {
HXLINE(  20)					HX_VARI_NAME( Int,z6,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  20)					Int _hx_tmp50 = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  20)					decodeState->acc = _hx_tmp50;
HXDLIN(  20)					hx::SubEq(decodeState->validBits,(int)8);
HXDLIN(  20)					_hx_tmp39 = z6;
            				}
            			}
            			else {
HXLINE(  20)				HX_VARI_NAME( Int,z7,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  20)				Int _hx_tmp51 = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  20)				decodeState->acc = _hx_tmp51;
HXDLIN(  20)				hx::SubEq(decodeState->validBits,(int)8);
HXDLIN(  20)				_hx_tmp39 = z7;
            			}
            		}
HXDLIN(  20)		m->mapping = _hx_tmp39;
HXLINE(  21)		if ((m->windowtype != (int)0)) {
HXLINE(  22)			HX_STACK_DO_THROW( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__new(::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Mode.hx",1b,97,89,ba),22,HX_("kha.audio2.ogg.vorbis.data.Mode",33,9e,c1,c7),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  24)		if ((m->transformtype != (int)0)) {
HXLINE(  25)			HX_STACK_DO_THROW( ::kha::audio2::ogg::vorbis::data::ReaderError_obj::__new(::kha::audio2::ogg::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Mode.hx",1b,97,89,ba),25,HX_("kha.audio2.ogg.vorbis.data.Mode",33,9e,c1,c7),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  27)		return m;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Mode_obj,read,return )


Mode_obj::Mode_obj()
{
}

hx::Val Mode_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"mapping") ) { return hx::Val( mapping); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"blockflag") ) { return hx::Val( blockflag); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"windowtype") ) { return hx::Val( windowtype); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"transformtype") ) { return hx::Val( transformtype); }
	}
	return super::__Field(inName,inCallProp);
}

bool Mode_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"read") ) { outValue = read_dyn(); return true; }
	}
	return false;
}

hx::Val Mode_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"mapping") ) { mapping=inValue.Cast< Int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"blockflag") ) { blockflag=inValue.Cast< Bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"windowtype") ) { windowtype=inValue.Cast< Int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"transformtype") ) { transformtype=inValue.Cast< Int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Mode_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("blockflag","\x79","\xab","\x73","\x5e"));
	outFields->push(HX_HCSTRING("mapping","\x0e","\x7b","\x7a","\x44"));
	outFields->push(HX_HCSTRING("windowtype","\xaa","\x3e","\x06","\xed"));
	outFields->push(HX_HCSTRING("transformtype","\x26","\x46","\x7d","\x8f"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Mode_obj_sMemberStorageInfo[] = {
	{hx::fsBool,(int)offsetof(Mode_obj,blockflag),HX_HCSTRING("blockflag","\x79","\xab","\x73","\x5e")},
	{hx::fsInt,(int)offsetof(Mode_obj,mapping),HX_HCSTRING("mapping","\x0e","\x7b","\x7a","\x44")},
	{hx::fsInt,(int)offsetof(Mode_obj,windowtype),HX_HCSTRING("windowtype","\xaa","\x3e","\x06","\xed")},
	{hx::fsInt,(int)offsetof(Mode_obj,transformtype),HX_HCSTRING("transformtype","\x26","\x46","\x7d","\x8f")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Mode_obj_sStaticStorageInfo = 0;
#endif

static ::String Mode_obj_sMemberFields[] = {
	HX_HCSTRING("blockflag","\x79","\xab","\x73","\x5e"),
	HX_HCSTRING("mapping","\x0e","\x7b","\x7a","\x44"),
	HX_HCSTRING("windowtype","\xaa","\x3e","\x06","\xed"),
	HX_HCSTRING("transformtype","\x26","\x46","\x7d","\x8f"),
	::String(null()) };

static void Mode_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Mode_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Mode_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Mode_obj::__mClass,"__mClass");
};

#endif

hx::Class Mode_obj::__mClass;

static ::String Mode_obj_sStaticFields[] = {
	HX_HCSTRING("read","\x56","\x4b","\xa7","\x4b"),
	::String(null())
};

void Mode_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("kha.audio2.ogg.vorbis.data.Mode","\x33","\x9e","\xc1","\xc7");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Mode_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Mode_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Mode_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Mode_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Mode_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Mode_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Mode_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Mode_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace kha
} // end namespace audio2
} // end namespace ogg
} // end namespace vorbis
} // end namespace data
