// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_cpp_vm_Mutex
#include <cpp/vm/Mutex.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_kha_Resource
#include <kha/Resource.h>
#endif
#ifndef INCLUDED_kha_Sound
#include <kha/Sound.h>
#endif
#ifndef INCLUDED_kha_audio1_AudioChannel
#include <kha/audio1/AudioChannel.h>
#endif
#ifndef INCLUDED_kha_audio2_Audio
#include <kha/audio2/Audio.h>
#endif
#ifndef INCLUDED_kha_audio2_Audio1
#include <kha/audio2/Audio1.h>
#endif
#ifndef INCLUDED_kha_audio2_AudioChannel
#include <kha/audio2/AudioChannel.h>
#endif
#ifndef INCLUDED_kha_audio2_Buffer
#include <kha/audio2/Buffer.h>
#endif
#ifndef INCLUDED_kha_audio2_StreamChannel
#include <kha/audio2/StreamChannel.h>
#endif

namespace kha{
namespace audio2{

void Audio1_obj::__construct() { }

Dynamic Audio1_obj::__CreateEmpty() { return new Audio1_obj; }

hx::ObjectPtr< Audio1_obj > Audio1_obj::__new()
{
	hx::ObjectPtr< Audio1_obj > _hx_result = new Audio1_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic Audio1_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Audio1_obj > _hx_result = new Audio1_obj();
	_hx_result->__construct();
	return _hx_result;
}

Int Audio1_obj::channelCount;

::Array< ::Dynamic> Audio1_obj::soundChannels;

::Array< ::Dynamic> Audio1_obj::streamChannels;

::Array< ::Dynamic> Audio1_obj::internalSoundChannels;

::Array< ::Dynamic> Audio1_obj::internalStreamChannels;

::Array< float > Audio1_obj::sampleCache1;

::Array< float > Audio1_obj::sampleCache2;

 ::cpp::vm::Mutex Audio1_obj::mutex;

void Audio1_obj::_init(){
            	HX_STACK_FRAME("kha.audio2.Audio1","_init",0x394948c4,"kha.audio2.Audio1._init","kha/audio2/Audio1.hx",22,0x063d6bfb)
HXLINE(  24)		::kha::audio2::Audio1_obj::mutex =  ::cpp::vm::Mutex_obj::__new();
HXLINE(  26)		HX_VARI_NAME( ::Array< ::Dynamic>,this1,"this") = ::Array_obj< ::Dynamic>::__new();
HXDLIN(  26)		_hx_array_set_size_exact(this1,(int)16);
HXDLIN(  26)		::kha::audio2::Audio1_obj::soundChannels = this1;
HXLINE(  27)		HX_VARI_NAME( ::Array< ::Dynamic>,this2,"this") = ::Array_obj< ::Dynamic>::__new();
HXDLIN(  27)		_hx_array_set_size_exact(this2,(int)16);
HXDLIN(  27)		::kha::audio2::Audio1_obj::streamChannels = this2;
HXLINE(  28)		HX_VARI_NAME( ::Array< ::Dynamic>,this3,"this") = ::Array_obj< ::Dynamic>::__new();
HXDLIN(  28)		_hx_array_set_size_exact(this3,(int)16);
HXDLIN(  28)		::kha::audio2::Audio1_obj::internalSoundChannels = this3;
HXLINE(  29)		HX_VARI_NAME( ::Array< ::Dynamic>,this4,"this") = ::Array_obj< ::Dynamic>::__new();
HXDLIN(  29)		_hx_array_set_size_exact(this4,(int)16);
HXDLIN(  29)		::kha::audio2::Audio1_obj::internalStreamChannels = this4;
HXLINE(  30)		HX_VARI_NAME( ::Array< float >,this5,"this") = ::Array_obj< float >::__new();
HXDLIN(  30)		_hx_array_set_size_exact(this5,(int)512);
HXDLIN(  30)		::kha::audio2::Audio1_obj::sampleCache1 = this5;
HXLINE(  31)		HX_VARI_NAME( ::Array< float >,this6,"this") = ::Array_obj< float >::__new();
HXDLIN(  31)		_hx_array_set_size_exact(this6,(int)512);
HXDLIN(  31)		::kha::audio2::Audio1_obj::sampleCache2 = this6;
HXLINE(  32)		::kha::audio2::Audio_obj::audioCallback = ::kha::audio2::Audio1_obj::_mix_dyn();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Audio1_obj,_init,(void))

Float Audio1_obj::max(Float a,Float b){
            	HX_STACK_FRAME("kha.audio2.Audio1","max",0xdc426d39,"kha.audio2.Audio1.max","kha/audio2/Audio1.hx",36,0x063d6bfb)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE(  36)		if ((a > b)) {
HXLINE(  36)			return a;
            		}
            		else {
HXLINE(  36)			return b;
            		}
HXDLIN(  36)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Audio1_obj,max,return )

Float Audio1_obj::min(Float a,Float b){
            	HX_STACK_FRAME("kha.audio2.Audio1","min",0xdc427427,"kha.audio2.Audio1.min","kha/audio2/Audio1.hx",40,0x063d6bfb)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE(  40)		if ((a < b)) {
HXLINE(  40)			return a;
            		}
            		else {
HXLINE(  40)			return b;
            		}
HXDLIN(  40)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Audio1_obj,min,return )

void Audio1_obj::_mix(Int samples, ::kha::audio2::Buffer buffer){
            	HX_STACK_FRAME("kha.audio2.Audio1","_mix",0xd4a53668,"kha.audio2.Audio1._mix","kha/audio2/Audio1.hx",43,0x063d6bfb)
            	HX_STACK_ARG(samples,"samples")
            	HX_STACK_ARG(buffer,"buffer")
HXLINE(  44)		Bool _hx_tmp = (::kha::audio2::Audio1_obj::sampleCache1->length < samples);
HXDLIN(  44)		if (_hx_tmp) {
HXLINE(  45)			HX_VARI_NAME( ::Array< float >,this1,"this") = ::Array_obj< float >::__new();
HXDLIN(  45)			_hx_array_set_size_exact(this1,samples);
HXDLIN(  45)			::kha::audio2::Audio1_obj::sampleCache1 = this1;
HXLINE(  46)			HX_VARI_NAME( ::Array< float >,this2,"this") = ::Array_obj< float >::__new();
HXDLIN(  46)			_hx_array_set_size_exact(this2,samples);
HXDLIN(  46)			::kha::audio2::Audio1_obj::sampleCache2 = this2;
            		}
HXLINE(  48)		{
HXLINE(  48)			HX_VARI( Int,_g1) = (int)0;
HXDLIN(  48)			while((_g1 < samples)){
HXLINE(  48)				HX_VARI( Int,i) = _g1++;
HXLINE(  49)				::kha::audio2::Audio1_obj::sampleCache2->__unsafe_set(i,(int)0);
            			}
            		}
HXLINE(  53)		::kha::audio2::Audio1_obj::mutex->acquire();
HXLINE(  55)		{
HXLINE(  55)			HX_VARI( Int,_g) = (int)0;
HXDLIN(  55)			while((_g < (int)16)){
HXLINE(  55)				HX_VARI_NAME( Int,i1,"i") = _g++;
HXLINE(  56)				{
HXLINE(  56)					 ::kha::audio2::AudioChannel val = ( ( ::kha::audio2::AudioChannel)(_hx_array_unsafe_get(::kha::audio2::Audio1_obj::soundChannels,i1)) );
HXDLIN(  56)					::kha::audio2::Audio1_obj::internalSoundChannels->__unsafe_set(i1,val);
            				}
            			}
            		}
HXLINE(  58)		{
HXLINE(  58)			HX_VARI_NAME( Int,_g2,"_g") = (int)0;
HXDLIN(  58)			while((_g2 < (int)16)){
HXLINE(  58)				HX_VARI_NAME( Int,i2,"i") = _g2++;
HXLINE(  59)				{
HXLINE(  59)					 ::kha::audio2::StreamChannel val1 = ( ( ::kha::audio2::StreamChannel)(_hx_array_unsafe_get(::kha::audio2::Audio1_obj::streamChannels,i2)) );
HXDLIN(  59)					::kha::audio2::Audio1_obj::internalStreamChannels->__unsafe_set(i2,val1);
            				}
            			}
            		}
HXLINE(  62)		::kha::audio2::Audio1_obj::mutex->release();
HXLINE(  65)		{
HXLINE(  65)			HX_VARI_NAME( Int,_g3,"_g") = (int)0;
HXDLIN(  65)			HX_VARI_NAME( ::Array< ::Dynamic>,_g11,"_g1") = ::kha::audio2::Audio1_obj::internalSoundChannels;
HXDLIN(  65)			while((_g3 < _g11->length)){
HXLINE(  65)				HX_VARI(  ::kha::audio2::AudioChannel,channel) = ( ( ::kha::audio2::AudioChannel)(_hx_array_unsafe_get(_g11,_g3)) );
HXDLIN(  65)				++_g3;
HXLINE(  66)				Bool _hx_tmp1;
HXDLIN(  66)				Bool _hx_tmp2 = hx::IsNotNull( channel );
HXDLIN(  66)				if (_hx_tmp2) {
HXLINE(  66)					_hx_tmp1 = channel->get_finished();
            				}
            				else {
HXLINE(  66)					_hx_tmp1 = true;
            				}
HXDLIN(  66)				if (_hx_tmp1) {
HXLINE(  66)					continue;
            				}
HXLINE(  67)				channel->nextSamples(::kha::audio2::Audio1_obj::sampleCache1,samples,buffer->samplesPerSecond);
HXLINE(  68)				{
HXLINE(  68)					HX_VARI_NAME( Int,_g31,"_g3") = (int)0;
HXDLIN(  68)					while((_g31 < samples)){
HXLINE(  68)						HX_VARI_NAME( Int,i3,"i") = _g31++;
HXLINE(  69)						{
HXLINE(  69)							float _hx_tmp3 = ( (float)(_hx_array_unsafe_get(::kha::audio2::Audio1_obj::sampleCache2,i3)) );
HXDLIN(  69)							float _hx_tmp4 = ( (float)(_hx_array_unsafe_get(::kha::audio2::Audio1_obj::sampleCache1,i3)) );
HXDLIN(  69)							Float _hx_tmp5 = channel->get_volume();
HXDLIN(  69)							::kha::audio2::Audio1_obj::sampleCache2->__unsafe_set(i3,(_hx_tmp3 + (_hx_tmp4 * _hx_tmp5)));
            						}
            					}
            				}
            			}
            		}
HXLINE(  72)		{
HXLINE(  72)			HX_VARI_NAME( Int,_g4,"_g") = (int)0;
HXDLIN(  72)			HX_VARI_NAME( ::Array< ::Dynamic>,_g12,"_g1") = ::kha::audio2::Audio1_obj::internalStreamChannels;
HXDLIN(  72)			while((_g4 < _g12->length)){
HXLINE(  72)				HX_VARI_NAME(  ::kha::audio2::StreamChannel,channel1,"channel") = ( ( ::kha::audio2::StreamChannel)(_hx_array_unsafe_get(_g12,_g4)) );
HXDLIN(  72)				++_g4;
HXLINE(  73)				Bool _hx_tmp6;
HXDLIN(  73)				Bool _hx_tmp7 = hx::IsNotNull( channel1 );
HXDLIN(  73)				if (_hx_tmp7) {
HXLINE(  73)					_hx_tmp6 = channel1->get_finished();
            				}
            				else {
HXLINE(  73)					_hx_tmp6 = true;
            				}
HXDLIN(  73)				if (_hx_tmp6) {
HXLINE(  73)					continue;
            				}
HXLINE(  74)				channel1->nextSamples(::kha::audio2::Audio1_obj::sampleCache1,samples,buffer->samplesPerSecond);
HXLINE(  75)				{
HXLINE(  75)					HX_VARI_NAME( Int,_g32,"_g3") = (int)0;
HXDLIN(  75)					while((_g32 < samples)){
HXLINE(  75)						HX_VARI_NAME( Int,i4,"i") = _g32++;
HXLINE(  76)						{
HXLINE(  76)							float _hx_tmp8 = ( (float)(_hx_array_unsafe_get(::kha::audio2::Audio1_obj::sampleCache2,i4)) );
HXDLIN(  76)							float _hx_tmp9 = ( (float)(_hx_array_unsafe_get(::kha::audio2::Audio1_obj::sampleCache1,i4)) );
HXDLIN(  76)							Float _hx_tmp10 = channel1->get_volume();
HXDLIN(  76)							::kha::audio2::Audio1_obj::sampleCache2->__unsafe_set(i4,(_hx_tmp8 + (_hx_tmp9 * _hx_tmp10)));
            						}
            					}
            				}
            			}
            		}
HXLINE(  80)		{
HXLINE(  80)			HX_VARI_NAME( Int,_g13,"_g1") = (int)0;
HXDLIN(  80)			while((_g13 < samples)){
HXLINE(  80)				HX_VARI_NAME( Int,i5,"i") = _g13++;
HXLINE(  81)				{
HXLINE(  81)					Int index = buffer->writeLocation;
HXDLIN(  81)					HX_VARI( Float,a) = ( (float)(_hx_array_unsafe_get(::kha::audio2::Audio1_obj::sampleCache2,i5)) );
HXDLIN(  81)					HX_VAR_NAME( Float,a1,"a");
HXDLIN(  81)					if ((a < ((Float)1.0))) {
HXLINE(  81)						a1 = a;
            					}
            					else {
HXLINE(  81)						a1 = ((Float)1.0);
            					}
HXDLIN(  81)					Float val2;
HXDLIN(  81)					if ((a1 > ((Float)-1.0))) {
HXLINE(  81)						val2 = a1;
            					}
            					else {
HXLINE(  81)						val2 = ((Float)-1.0);
            					}
HXDLIN(  81)					buffer->data->__unsafe_set(index,val2);
            				}
HXLINE(  82)				hx::AddEq(buffer->writeLocation,(int)1);
HXLINE(  83)				Bool _hx_tmp11 = (buffer->writeLocation >= buffer->size);
HXDLIN(  83)				if (_hx_tmp11) {
HXLINE(  84)					buffer->writeLocation = (int)0;
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Audio1_obj,_mix,(void))

::Dynamic Audio1_obj::play( ::kha::Sound sound,hx::Null< Bool >  __o_loop){
Bool loop = __o_loop.Default(false);
            	HX_STACK_FRAME("kha.audio2.Audio1","play",0xdfe10dbf,"kha.audio2.Audio1.play","kha/audio2/Audio1.hx",89,0x063d6bfb)
            	HX_STACK_ARG(sound,"sound")
            	HX_STACK_ARG(loop,"loop")
HXLINE(  91)		::kha::audio2::Audio1_obj::mutex->acquire();
HXLINE(  93)		HX_VARI(  ::kha::audio2::AudioChannel,channel) = null();
HXLINE(  94)		{
HXLINE(  94)			HX_VARI( Int,_g) = (int)0;
HXDLIN(  94)			while((_g < (int)16)){
HXLINE(  94)				HX_VARI( Int,i) = _g++;
HXLINE(  95)				Bool _hx_tmp;
HXDLIN(  95)				Bool _hx_tmp1 = hx::IsNotNull( ( ( ::kha::audio2::AudioChannel)(_hx_array_unsafe_get(::kha::audio2::Audio1_obj::soundChannels,i)) ) );
HXDLIN(  95)				if (_hx_tmp1) {
HXLINE(  95)					_hx_tmp = ( ( ::kha::audio2::AudioChannel)(_hx_array_unsafe_get(::kha::audio2::Audio1_obj::soundChannels,i)) )->get_finished();
            				}
            				else {
HXLINE(  95)					_hx_tmp = true;
            				}
HXDLIN(  95)				if (_hx_tmp) {
HXLINE(  96)					channel =  ::kha::audio2::AudioChannel_obj::__new(loop);
HXLINE(  97)					channel->data = sound->uncompressedData;
HXLINE(  98)					::kha::audio2::Audio1_obj::soundChannels->__unsafe_set(i,channel);
HXLINE(  99)					goto _hx_goto_8;
            				}
            			}
            			_hx_goto_8:;
            		}
HXLINE( 103)		::kha::audio2::Audio1_obj::mutex->release();
HXLINE( 105)		return channel;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Audio1_obj,play,return )

::Dynamic Audio1_obj::stream( ::kha::Sound sound,hx::Null< Bool >  __o_loop){
Bool loop = __o_loop.Default(false);
            	HX_STACK_FRAME("kha.audio2.Audio1","stream",0x3e03bd0b,"kha.audio2.Audio1.stream","kha/audio2/Audio1.hx",108,0x063d6bfb)
            	HX_STACK_ARG(sound,"sound")
            	HX_STACK_ARG(loop,"loop")
HXLINE( 109)		{
HXLINE( 111)			HX_VARI( ::Dynamic,hardwareChannel) = ::kha::audio2::Audio_obj::stream(sound,loop);
HXLINE( 112)			Bool _hx_tmp = hx::IsNotNull( hardwareChannel );
HXDLIN( 112)			if (_hx_tmp) {
HXLINE( 112)				return hardwareChannel;
            			}
            		}
HXLINE( 116)		::kha::audio2::Audio1_obj::mutex->acquire();
HXLINE( 118)		HX_VARI(  ::kha::audio2::StreamChannel,channel) = null();
HXLINE( 119)		{
HXLINE( 119)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 119)			while((_g < (int)16)){
HXLINE( 119)				HX_VARI( Int,i) = _g++;
HXLINE( 120)				Bool _hx_tmp1;
HXDLIN( 120)				Bool _hx_tmp2 = hx::IsNotNull( ( ( ::kha::audio2::StreamChannel)(_hx_array_unsafe_get(::kha::audio2::Audio1_obj::streamChannels,i)) ) );
HXDLIN( 120)				if (_hx_tmp2) {
HXLINE( 120)					_hx_tmp1 = ( ( ::kha::audio2::StreamChannel)(_hx_array_unsafe_get(::kha::audio2::Audio1_obj::streamChannels,i)) )->get_finished();
            				}
            				else {
HXLINE( 120)					_hx_tmp1 = true;
            				}
HXDLIN( 120)				if (_hx_tmp1) {
HXLINE( 121)					channel =  ::kha::audio2::StreamChannel_obj::__new(sound->compressedData,loop);
HXLINE( 122)					::kha::audio2::Audio1_obj::streamChannels->__unsafe_set(i,channel);
HXLINE( 123)					goto _hx_goto_9;
            				}
            			}
            			_hx_goto_9:;
            		}
HXLINE( 127)		::kha::audio2::Audio1_obj::mutex->release();
HXLINE( 129)		return channel;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Audio1_obj,stream,return )


Audio1_obj::Audio1_obj()
{
}

bool Audio1_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"max") ) { outValue = max_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"min") ) { outValue = min_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"_mix") ) { outValue = _mix_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"play") ) { outValue = play_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"mutex") ) { outValue = mutex; return true; }
		if (HX_FIELD_EQ(inName,"_init") ) { outValue = _init_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"stream") ) { outValue = stream_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"sampleCache1") ) { outValue = sampleCache1; return true; }
		if (HX_FIELD_EQ(inName,"sampleCache2") ) { outValue = sampleCache2; return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"soundChannels") ) { outValue = soundChannels; return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"streamChannels") ) { outValue = streamChannels; return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"internalSoundChannels") ) { outValue = internalSoundChannels; return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"internalStreamChannels") ) { outValue = internalStreamChannels; return true; }
	}
	return false;
}

bool Audio1_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"mutex") ) { mutex=ioValue.Cast<  ::cpp::vm::Mutex >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"sampleCache1") ) { sampleCache1=ioValue.Cast< ::Array< float > >(); return true; }
		if (HX_FIELD_EQ(inName,"sampleCache2") ) { sampleCache2=ioValue.Cast< ::Array< float > >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"soundChannels") ) { soundChannels=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"streamChannels") ) { streamChannels=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"internalSoundChannels") ) { internalSoundChannels=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"internalStreamChannels") ) { internalStreamChannels=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Audio1_obj_sMemberStorageInfo = 0;
static hx::StaticInfo Audio1_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Audio1_obj::channelCount,HX_HCSTRING("channelCount","\x0c","\x11","\x16","\x4f")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &Audio1_obj::soundChannels,HX_HCSTRING("soundChannels","\x3f","\xda","\x0c","\x08")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &Audio1_obj::streamChannels,HX_HCSTRING("streamChannels","\xf0","\xfa","\xb5","\x1f")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &Audio1_obj::internalSoundChannels,HX_HCSTRING("internalSoundChannels","\xc2","\x40","\x9f","\xb5")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &Audio1_obj::internalStreamChannels,HX_HCSTRING("internalStreamChannels","\x0d","\x47","\x3d","\x52")},
	{hx::fsObject /*Array< ::cpp::Float32 >*/ ,(void *) &Audio1_obj::sampleCache1,HX_HCSTRING("sampleCache1","\x79","\xaf","\x5e","\xf5")},
	{hx::fsObject /*Array< ::cpp::Float32 >*/ ,(void *) &Audio1_obj::sampleCache2,HX_HCSTRING("sampleCache2","\x7a","\xaf","\x5e","\xf5")},
	{hx::fsObject /*::cpp::vm::Mutex*/ ,(void *) &Audio1_obj::mutex,HX_HCSTRING("mutex","\x7f","\x8f","\x5b","\x10")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void Audio1_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Audio1_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Audio1_obj::channelCount,"channelCount");
	HX_MARK_MEMBER_NAME(Audio1_obj::soundChannels,"soundChannels");
	HX_MARK_MEMBER_NAME(Audio1_obj::streamChannels,"streamChannels");
	HX_MARK_MEMBER_NAME(Audio1_obj::internalSoundChannels,"internalSoundChannels");
	HX_MARK_MEMBER_NAME(Audio1_obj::internalStreamChannels,"internalStreamChannels");
	HX_MARK_MEMBER_NAME(Audio1_obj::sampleCache1,"sampleCache1");
	HX_MARK_MEMBER_NAME(Audio1_obj::sampleCache2,"sampleCache2");
	HX_MARK_MEMBER_NAME(Audio1_obj::mutex,"mutex");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Audio1_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Audio1_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Audio1_obj::channelCount,"channelCount");
	HX_VISIT_MEMBER_NAME(Audio1_obj::soundChannels,"soundChannels");
	HX_VISIT_MEMBER_NAME(Audio1_obj::streamChannels,"streamChannels");
	HX_VISIT_MEMBER_NAME(Audio1_obj::internalSoundChannels,"internalSoundChannels");
	HX_VISIT_MEMBER_NAME(Audio1_obj::internalStreamChannels,"internalStreamChannels");
	HX_VISIT_MEMBER_NAME(Audio1_obj::sampleCache1,"sampleCache1");
	HX_VISIT_MEMBER_NAME(Audio1_obj::sampleCache2,"sampleCache2");
	HX_VISIT_MEMBER_NAME(Audio1_obj::mutex,"mutex");
};

#endif

hx::Class Audio1_obj::__mClass;

static ::String Audio1_obj_sStaticFields[] = {
	HX_HCSTRING("channelCount","\x0c","\x11","\x16","\x4f"),
	HX_HCSTRING("soundChannels","\x3f","\xda","\x0c","\x08"),
	HX_HCSTRING("streamChannels","\xf0","\xfa","\xb5","\x1f"),
	HX_HCSTRING("internalSoundChannels","\xc2","\x40","\x9f","\xb5"),
	HX_HCSTRING("internalStreamChannels","\x0d","\x47","\x3d","\x52"),
	HX_HCSTRING("sampleCache1","\x79","\xaf","\x5e","\xf5"),
	HX_HCSTRING("sampleCache2","\x7a","\xaf","\x5e","\xf5"),
	HX_HCSTRING("mutex","\x7f","\x8f","\x5b","\x10"),
	HX_HCSTRING("_init","\xef","\x56","\xcc","\xf8"),
	HX_HCSTRING("max","\xa4","\x0a","\x53","\x00"),
	HX_HCSTRING("min","\x92","\x11","\x53","\x00"),
	HX_HCSTRING("_mix","\x9d","\x56","\x1e","\x3f"),
	HX_HCSTRING("play","\xf4","\x2d","\x5a","\x4a"),
	HX_HCSTRING("stream","\x80","\x14","\x2d","\x11"),
	::String(null())
};

void Audio1_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("kha.audio2.Audio1","\x83","\x94","\xaf","\x7e");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Audio1_obj::__GetStatic;
	__mClass->mSetStaticField = &Audio1_obj::__SetStatic;
	__mClass->mMarkFunc = Audio1_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Audio1_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Audio1_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Audio1_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Audio1_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Audio1_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Audio1_obj::__boot()
{
{
            	HX_STACK_FRAME("kha.audio2.Audio1","boot",0xd6a263fd,"kha.audio2.Audio1.boot","kha/audio2/Audio1.hx",9,0x063d6bfb)
HXLINE(   9)		channelCount = (int)16;
            	}
}

} // end namespace kha
} // end namespace audio2
