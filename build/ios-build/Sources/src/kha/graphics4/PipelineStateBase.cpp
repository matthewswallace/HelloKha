// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_kha_graphics4_BlendingFactor
#include <kha/graphics4/BlendingFactor.h>
#endif
#ifndef INCLUDED_kha_graphics4_BlendingOperation
#include <kha/graphics4/BlendingOperation.h>
#endif
#ifndef INCLUDED_kha_graphics4_CompareMode
#include <kha/graphics4/CompareMode.h>
#endif
#ifndef INCLUDED_kha_graphics4_CullMode
#include <kha/graphics4/CullMode.h>
#endif
#ifndef INCLUDED_kha_graphics4_FragmentShader
#include <kha/graphics4/FragmentShader.h>
#endif
#ifndef INCLUDED_kha_graphics4_GeometryShader
#include <kha/graphics4/GeometryShader.h>
#endif
#ifndef INCLUDED_kha_graphics4_PipelineStateBase
#include <kha/graphics4/PipelineStateBase.h>
#endif
#ifndef INCLUDED_kha_graphics4_StencilAction
#include <kha/graphics4/StencilAction.h>
#endif
#ifndef INCLUDED_kha_graphics4_TessellationControlShader
#include <kha/graphics4/TessellationControlShader.h>
#endif
#ifndef INCLUDED_kha_graphics4_TessellationEvaluationShader
#include <kha/graphics4/TessellationEvaluationShader.h>
#endif
#ifndef INCLUDED_kha_graphics4_VertexShader
#include <kha/graphics4/VertexShader.h>
#endif
#ifndef INCLUDED_kha_graphics4_VertexStructure
#include <kha/graphics4/VertexStructure.h>
#endif

namespace kha{
namespace graphics4{

void PipelineStateBase_obj::__construct(){
            	HX_STACK_FRAME("kha.graphics4.PipelineStateBase","new",0x13b630a3,"kha.graphics4.PipelineStateBase.new","kha/graphics4/PipelineStateBase.hx",4,0x8daa4c6f)
            	HX_STACK_THIS(this)
HXLINE(   5)		this->inputLayout = null();
HXLINE(   6)		this->vertexShader = null();
HXLINE(   7)		this->fragmentShader = null();
HXLINE(   8)		this->geometryShader = null();
HXLINE(   9)		this->tessellationControlShader = null();
HXLINE(  10)		this->tessellationEvaluationShader = null();
HXLINE(  12)		this->cullMode = ::kha::graphics4::CullMode_obj::None_dyn();
HXLINE(  14)		this->depthWrite = false;
HXLINE(  15)		this->depthMode = ::kha::graphics4::CompareMode_obj::Always_dyn();
HXLINE(  17)		this->stencilMode = ::kha::graphics4::CompareMode_obj::Always_dyn();
HXLINE(  18)		this->stencilBothPass = ::kha::graphics4::StencilAction_obj::Keep_dyn();
HXLINE(  19)		this->stencilDepthFail = ::kha::graphics4::StencilAction_obj::Keep_dyn();
HXLINE(  20)		this->stencilFail = ::kha::graphics4::StencilAction_obj::Keep_dyn();
HXLINE(  21)		this->stencilReferenceValue = (int)0;
HXLINE(  22)		this->stencilReadMask = (int)255;
HXLINE(  23)		this->stencilWriteMask = (int)255;
HXLINE(  25)		this->blendSource = ::kha::graphics4::BlendingFactor_obj::BlendOne_dyn();
HXLINE(  26)		this->blendDestination = ::kha::graphics4::BlendingFactor_obj::BlendZero_dyn();
HXLINE(  27)		this->blendOperation = ::kha::graphics4::BlendingOperation_obj::Add_dyn();
HXLINE(  28)		this->alphaBlendSource = ::kha::graphics4::BlendingFactor_obj::BlendOne_dyn();
HXLINE(  29)		this->alphaBlendDestination = ::kha::graphics4::BlendingFactor_obj::BlendZero_dyn();
HXLINE(  30)		this->alphaBlendOperation = ::kha::graphics4::BlendingOperation_obj::Add_dyn();
HXLINE(  32)		this->colorWriteMaskRed = (this->colorWriteMaskBlue = (this->colorWriteMaskGreen = (this->colorWriteMaskAlpha = true)));
            	}

Dynamic PipelineStateBase_obj::__CreateEmpty() { return new PipelineStateBase_obj; }

hx::ObjectPtr< PipelineStateBase_obj > PipelineStateBase_obj::__new()
{
	hx::ObjectPtr< PipelineStateBase_obj > _hx_result = new PipelineStateBase_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic PipelineStateBase_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< PipelineStateBase_obj > _hx_result = new PipelineStateBase_obj();
	_hx_result->__construct();
	return _hx_result;
}

Bool PipelineStateBase_obj::set_colorWriteMask(Bool value){
            	HX_STACK_FRAME("kha.graphics4.PipelineStateBase","set_colorWriteMask",0x6ce455e2,"kha.graphics4.PipelineStateBase.set_colorWriteMask","kha/graphics4/PipelineStateBase.hx",70,0x8daa4c6f)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(  70)		return (this->colorWriteMaskRed = (this->colorWriteMaskBlue = (this->colorWriteMaskGreen = (this->colorWriteMaskAlpha = value))));
            	}


HX_DEFINE_DYNAMIC_FUNC1(PipelineStateBase_obj,set_colorWriteMask,return )


PipelineStateBase_obj::PipelineStateBase_obj()
{
}

void PipelineStateBase_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(PipelineStateBase);
	HX_MARK_MEMBER_NAME(inputLayout,"inputLayout");
	HX_MARK_MEMBER_NAME(vertexShader,"vertexShader");
	HX_MARK_MEMBER_NAME(fragmentShader,"fragmentShader");
	HX_MARK_MEMBER_NAME(geometryShader,"geometryShader");
	HX_MARK_MEMBER_NAME(tessellationControlShader,"tessellationControlShader");
	HX_MARK_MEMBER_NAME(tessellationEvaluationShader,"tessellationEvaluationShader");
	HX_MARK_MEMBER_NAME(cullMode,"cullMode");
	HX_MARK_MEMBER_NAME(depthWrite,"depthWrite");
	HX_MARK_MEMBER_NAME(depthMode,"depthMode");
	HX_MARK_MEMBER_NAME(stencilMode,"stencilMode");
	HX_MARK_MEMBER_NAME(stencilBothPass,"stencilBothPass");
	HX_MARK_MEMBER_NAME(stencilDepthFail,"stencilDepthFail");
	HX_MARK_MEMBER_NAME(stencilFail,"stencilFail");
	HX_MARK_MEMBER_NAME(stencilReferenceValue,"stencilReferenceValue");
	HX_MARK_MEMBER_NAME(stencilReadMask,"stencilReadMask");
	HX_MARK_MEMBER_NAME(stencilWriteMask,"stencilWriteMask");
	HX_MARK_MEMBER_NAME(blendSource,"blendSource");
	HX_MARK_MEMBER_NAME(blendDestination,"blendDestination");
	HX_MARK_MEMBER_NAME(blendOperation,"blendOperation");
	HX_MARK_MEMBER_NAME(alphaBlendSource,"alphaBlendSource");
	HX_MARK_MEMBER_NAME(alphaBlendDestination,"alphaBlendDestination");
	HX_MARK_MEMBER_NAME(alphaBlendOperation,"alphaBlendOperation");
	HX_MARK_MEMBER_NAME(colorWriteMaskRed,"colorWriteMaskRed");
	HX_MARK_MEMBER_NAME(colorWriteMaskGreen,"colorWriteMaskGreen");
	HX_MARK_MEMBER_NAME(colorWriteMaskBlue,"colorWriteMaskBlue");
	HX_MARK_MEMBER_NAME(colorWriteMaskAlpha,"colorWriteMaskAlpha");
	HX_MARK_END_CLASS();
}

void PipelineStateBase_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(inputLayout,"inputLayout");
	HX_VISIT_MEMBER_NAME(vertexShader,"vertexShader");
	HX_VISIT_MEMBER_NAME(fragmentShader,"fragmentShader");
	HX_VISIT_MEMBER_NAME(geometryShader,"geometryShader");
	HX_VISIT_MEMBER_NAME(tessellationControlShader,"tessellationControlShader");
	HX_VISIT_MEMBER_NAME(tessellationEvaluationShader,"tessellationEvaluationShader");
	HX_VISIT_MEMBER_NAME(cullMode,"cullMode");
	HX_VISIT_MEMBER_NAME(depthWrite,"depthWrite");
	HX_VISIT_MEMBER_NAME(depthMode,"depthMode");
	HX_VISIT_MEMBER_NAME(stencilMode,"stencilMode");
	HX_VISIT_MEMBER_NAME(stencilBothPass,"stencilBothPass");
	HX_VISIT_MEMBER_NAME(stencilDepthFail,"stencilDepthFail");
	HX_VISIT_MEMBER_NAME(stencilFail,"stencilFail");
	HX_VISIT_MEMBER_NAME(stencilReferenceValue,"stencilReferenceValue");
	HX_VISIT_MEMBER_NAME(stencilReadMask,"stencilReadMask");
	HX_VISIT_MEMBER_NAME(stencilWriteMask,"stencilWriteMask");
	HX_VISIT_MEMBER_NAME(blendSource,"blendSource");
	HX_VISIT_MEMBER_NAME(blendDestination,"blendDestination");
	HX_VISIT_MEMBER_NAME(blendOperation,"blendOperation");
	HX_VISIT_MEMBER_NAME(alphaBlendSource,"alphaBlendSource");
	HX_VISIT_MEMBER_NAME(alphaBlendDestination,"alphaBlendDestination");
	HX_VISIT_MEMBER_NAME(alphaBlendOperation,"alphaBlendOperation");
	HX_VISIT_MEMBER_NAME(colorWriteMaskRed,"colorWriteMaskRed");
	HX_VISIT_MEMBER_NAME(colorWriteMaskGreen,"colorWriteMaskGreen");
	HX_VISIT_MEMBER_NAME(colorWriteMaskBlue,"colorWriteMaskBlue");
	HX_VISIT_MEMBER_NAME(colorWriteMaskAlpha,"colorWriteMaskAlpha");
}

hx::Val PipelineStateBase_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"cullMode") ) { return hx::Val( cullMode); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"depthMode") ) { return hx::Val( depthMode); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"depthWrite") ) { return hx::Val( depthWrite); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"inputLayout") ) { return hx::Val( inputLayout); }
		if (HX_FIELD_EQ(inName,"stencilMode") ) { return hx::Val( stencilMode); }
		if (HX_FIELD_EQ(inName,"stencilFail") ) { return hx::Val( stencilFail); }
		if (HX_FIELD_EQ(inName,"blendSource") ) { return hx::Val( blendSource); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"vertexShader") ) { return hx::Val( vertexShader); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"fragmentShader") ) { return hx::Val( fragmentShader); }
		if (HX_FIELD_EQ(inName,"geometryShader") ) { return hx::Val( geometryShader); }
		if (HX_FIELD_EQ(inName,"blendOperation") ) { return hx::Val( blendOperation); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"stencilBothPass") ) { return hx::Val( stencilBothPass); }
		if (HX_FIELD_EQ(inName,"stencilReadMask") ) { return hx::Val( stencilReadMask); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"stencilDepthFail") ) { return hx::Val( stencilDepthFail); }
		if (HX_FIELD_EQ(inName,"stencilWriteMask") ) { return hx::Val( stencilWriteMask); }
		if (HX_FIELD_EQ(inName,"blendDestination") ) { return hx::Val( blendDestination); }
		if (HX_FIELD_EQ(inName,"alphaBlendSource") ) { return hx::Val( alphaBlendSource); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"colorWriteMaskRed") ) { return hx::Val( colorWriteMaskRed); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"colorWriteMaskBlue") ) { return hx::Val( colorWriteMaskBlue); }
		if (HX_FIELD_EQ(inName,"set_colorWriteMask") ) { return hx::Val( set_colorWriteMask_dyn()); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"alphaBlendOperation") ) { return hx::Val( alphaBlendOperation); }
		if (HX_FIELD_EQ(inName,"colorWriteMaskGreen") ) { return hx::Val( colorWriteMaskGreen); }
		if (HX_FIELD_EQ(inName,"colorWriteMaskAlpha") ) { return hx::Val( colorWriteMaskAlpha); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"stencilReferenceValue") ) { return hx::Val( stencilReferenceValue); }
		if (HX_FIELD_EQ(inName,"alphaBlendDestination") ) { return hx::Val( alphaBlendDestination); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"tessellationControlShader") ) { return hx::Val( tessellationControlShader); }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"tessellationEvaluationShader") ) { return hx::Val( tessellationEvaluationShader); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val PipelineStateBase_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"cullMode") ) { cullMode=inValue.Cast< ::hx::EnumBase >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"depthMode") ) { depthMode=inValue.Cast< ::hx::EnumBase >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"depthWrite") ) { depthWrite=inValue.Cast< Bool >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"inputLayout") ) { inputLayout=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stencilMode") ) { stencilMode=inValue.Cast< ::hx::EnumBase >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stencilFail") ) { stencilFail=inValue.Cast< ::hx::EnumBase >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blendSource") ) { blendSource=inValue.Cast< ::hx::EnumBase >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"vertexShader") ) { vertexShader=inValue.Cast<  ::kha::graphics4::VertexShader >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"fragmentShader") ) { fragmentShader=inValue.Cast<  ::kha::graphics4::FragmentShader >(); return inValue; }
		if (HX_FIELD_EQ(inName,"geometryShader") ) { geometryShader=inValue.Cast<  ::kha::graphics4::GeometryShader >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blendOperation") ) { blendOperation=inValue.Cast< ::hx::EnumBase >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorWriteMask") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_colorWriteMask(inValue) ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"stencilBothPass") ) { stencilBothPass=inValue.Cast< ::hx::EnumBase >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stencilReadMask") ) { stencilReadMask=inValue.Cast< Int >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"stencilDepthFail") ) { stencilDepthFail=inValue.Cast< ::hx::EnumBase >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stencilWriteMask") ) { stencilWriteMask=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blendDestination") ) { blendDestination=inValue.Cast< ::hx::EnumBase >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphaBlendSource") ) { alphaBlendSource=inValue.Cast< ::hx::EnumBase >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"colorWriteMaskRed") ) { colorWriteMaskRed=inValue.Cast< Bool >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"colorWriteMaskBlue") ) { colorWriteMaskBlue=inValue.Cast< Bool >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"alphaBlendOperation") ) { alphaBlendOperation=inValue.Cast< ::hx::EnumBase >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorWriteMaskGreen") ) { colorWriteMaskGreen=inValue.Cast< Bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorWriteMaskAlpha") ) { colorWriteMaskAlpha=inValue.Cast< Bool >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"stencilReferenceValue") ) { stencilReferenceValue=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphaBlendDestination") ) { alphaBlendDestination=inValue.Cast< ::hx::EnumBase >(); return inValue; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"tessellationControlShader") ) { tessellationControlShader=inValue.Cast<  ::kha::graphics4::TessellationControlShader >(); return inValue; }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"tessellationEvaluationShader") ) { tessellationEvaluationShader=inValue.Cast<  ::kha::graphics4::TessellationEvaluationShader >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void PipelineStateBase_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("inputLayout","\x54","\x8a","\xec","\x4d"));
	outFields->push(HX_HCSTRING("vertexShader","\xa9","\xb1","\x35","\xbd"));
	outFields->push(HX_HCSTRING("fragmentShader","\x15","\x4f","\xdc","\x39"));
	outFields->push(HX_HCSTRING("geometryShader","\x77","\x47","\xf8","\x1d"));
	outFields->push(HX_HCSTRING("tessellationControlShader","\xe1","\x21","\x63","\x5c"));
	outFields->push(HX_HCSTRING("tessellationEvaluationShader","\xe2","\x94","\x02","\xa5"));
	outFields->push(HX_HCSTRING("cullMode","\x35","\x06","\xdd","\xb0"));
	outFields->push(HX_HCSTRING("depthWrite","\xdc","\x60","\xc5","\x2c"));
	outFields->push(HX_HCSTRING("depthMode","\x06","\x2e","\xe4","\x9e"));
	outFields->push(HX_HCSTRING("stencilMode","\x7f","\x6b","\x5a","\x45"));
	outFields->push(HX_HCSTRING("stencilBothPass","\x0e","\x44","\x39","\xda"));
	outFields->push(HX_HCSTRING("stencilDepthFail","\xe5","\x96","\x76","\x67"));
	outFields->push(HX_HCSTRING("stencilFail","\xfa","\x51","\xaf","\x40"));
	outFields->push(HX_HCSTRING("stencilReferenceValue","\xc2","\x1a","\x35","\x60"));
	outFields->push(HX_HCSTRING("stencilReadMask","\x7e","\xf1","\x2b","\xe5"));
	outFields->push(HX_HCSTRING("stencilWriteMask","\xcf","\xb7","\x47","\x1e"));
	outFields->push(HX_HCSTRING("blendSource","\x0c","\xa0","\xa3","\xe6"));
	outFields->push(HX_HCSTRING("blendDestination","\xbd","\xe9","\xa3","\x86"));
	outFields->push(HX_HCSTRING("blendOperation","\x96","\x69","\xd1","\xa2"));
	outFields->push(HX_HCSTRING("alphaBlendSource","\x4e","\x31","\xcd","\x89"));
	outFields->push(HX_HCSTRING("alphaBlendDestination","\x3b","\x89","\xba","\xf1"));
	outFields->push(HX_HCSTRING("alphaBlendOperation","\x94","\x8d","\xd8","\xa2"));
	outFields->push(HX_HCSTRING("colorWriteMask","\x88","\xdf","\xb6","\xb8"));
	outFields->push(HX_HCSTRING("colorWriteMaskRed","\xa9","\x16","\xc2","\xdd"));
	outFields->push(HX_HCSTRING("colorWriteMaskGreen","\x1b","\x52","\xa4","\x16"));
	outFields->push(HX_HCSTRING("colorWriteMaskBlue","\x42","\xb2","\x83","\x21"));
	outFields->push(HX_HCSTRING("colorWriteMaskAlpha","\xb6","\xea","\x4d","\x9e"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo PipelineStateBase_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(PipelineStateBase_obj,inputLayout),HX_HCSTRING("inputLayout","\x54","\x8a","\xec","\x4d")},
	{hx::fsObject /*::kha::graphics4::VertexShader*/ ,(int)offsetof(PipelineStateBase_obj,vertexShader),HX_HCSTRING("vertexShader","\xa9","\xb1","\x35","\xbd")},
	{hx::fsObject /*::kha::graphics4::FragmentShader*/ ,(int)offsetof(PipelineStateBase_obj,fragmentShader),HX_HCSTRING("fragmentShader","\x15","\x4f","\xdc","\x39")},
	{hx::fsObject /*::kha::graphics4::GeometryShader*/ ,(int)offsetof(PipelineStateBase_obj,geometryShader),HX_HCSTRING("geometryShader","\x77","\x47","\xf8","\x1d")},
	{hx::fsObject /*::kha::graphics4::TessellationControlShader*/ ,(int)offsetof(PipelineStateBase_obj,tessellationControlShader),HX_HCSTRING("tessellationControlShader","\xe1","\x21","\x63","\x5c")},
	{hx::fsObject /*::kha::graphics4::TessellationEvaluationShader*/ ,(int)offsetof(PipelineStateBase_obj,tessellationEvaluationShader),HX_HCSTRING("tessellationEvaluationShader","\xe2","\x94","\x02","\xa5")},
	{hx::fsObject /*::kha::graphics4::CullMode*/ ,(int)offsetof(PipelineStateBase_obj,cullMode),HX_HCSTRING("cullMode","\x35","\x06","\xdd","\xb0")},
	{hx::fsBool,(int)offsetof(PipelineStateBase_obj,depthWrite),HX_HCSTRING("depthWrite","\xdc","\x60","\xc5","\x2c")},
	{hx::fsObject /*::kha::graphics4::CompareMode*/ ,(int)offsetof(PipelineStateBase_obj,depthMode),HX_HCSTRING("depthMode","\x06","\x2e","\xe4","\x9e")},
	{hx::fsObject /*::kha::graphics4::CompareMode*/ ,(int)offsetof(PipelineStateBase_obj,stencilMode),HX_HCSTRING("stencilMode","\x7f","\x6b","\x5a","\x45")},
	{hx::fsObject /*::kha::graphics4::StencilAction*/ ,(int)offsetof(PipelineStateBase_obj,stencilBothPass),HX_HCSTRING("stencilBothPass","\x0e","\x44","\x39","\xda")},
	{hx::fsObject /*::kha::graphics4::StencilAction*/ ,(int)offsetof(PipelineStateBase_obj,stencilDepthFail),HX_HCSTRING("stencilDepthFail","\xe5","\x96","\x76","\x67")},
	{hx::fsObject /*::kha::graphics4::StencilAction*/ ,(int)offsetof(PipelineStateBase_obj,stencilFail),HX_HCSTRING("stencilFail","\xfa","\x51","\xaf","\x40")},
	{hx::fsInt,(int)offsetof(PipelineStateBase_obj,stencilReferenceValue),HX_HCSTRING("stencilReferenceValue","\xc2","\x1a","\x35","\x60")},
	{hx::fsInt,(int)offsetof(PipelineStateBase_obj,stencilReadMask),HX_HCSTRING("stencilReadMask","\x7e","\xf1","\x2b","\xe5")},
	{hx::fsInt,(int)offsetof(PipelineStateBase_obj,stencilWriteMask),HX_HCSTRING("stencilWriteMask","\xcf","\xb7","\x47","\x1e")},
	{hx::fsObject /*::kha::graphics4::BlendingFactor*/ ,(int)offsetof(PipelineStateBase_obj,blendSource),HX_HCSTRING("blendSource","\x0c","\xa0","\xa3","\xe6")},
	{hx::fsObject /*::kha::graphics4::BlendingFactor*/ ,(int)offsetof(PipelineStateBase_obj,blendDestination),HX_HCSTRING("blendDestination","\xbd","\xe9","\xa3","\x86")},
	{hx::fsObject /*::kha::graphics4::BlendingOperation*/ ,(int)offsetof(PipelineStateBase_obj,blendOperation),HX_HCSTRING("blendOperation","\x96","\x69","\xd1","\xa2")},
	{hx::fsObject /*::kha::graphics4::BlendingFactor*/ ,(int)offsetof(PipelineStateBase_obj,alphaBlendSource),HX_HCSTRING("alphaBlendSource","\x4e","\x31","\xcd","\x89")},
	{hx::fsObject /*::kha::graphics4::BlendingFactor*/ ,(int)offsetof(PipelineStateBase_obj,alphaBlendDestination),HX_HCSTRING("alphaBlendDestination","\x3b","\x89","\xba","\xf1")},
	{hx::fsObject /*::kha::graphics4::BlendingOperation*/ ,(int)offsetof(PipelineStateBase_obj,alphaBlendOperation),HX_HCSTRING("alphaBlendOperation","\x94","\x8d","\xd8","\xa2")},
	{hx::fsBool,(int)offsetof(PipelineStateBase_obj,colorWriteMaskRed),HX_HCSTRING("colorWriteMaskRed","\xa9","\x16","\xc2","\xdd")},
	{hx::fsBool,(int)offsetof(PipelineStateBase_obj,colorWriteMaskGreen),HX_HCSTRING("colorWriteMaskGreen","\x1b","\x52","\xa4","\x16")},
	{hx::fsBool,(int)offsetof(PipelineStateBase_obj,colorWriteMaskBlue),HX_HCSTRING("colorWriteMaskBlue","\x42","\xb2","\x83","\x21")},
	{hx::fsBool,(int)offsetof(PipelineStateBase_obj,colorWriteMaskAlpha),HX_HCSTRING("colorWriteMaskAlpha","\xb6","\xea","\x4d","\x9e")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *PipelineStateBase_obj_sStaticStorageInfo = 0;
#endif

static ::String PipelineStateBase_obj_sMemberFields[] = {
	HX_HCSTRING("inputLayout","\x54","\x8a","\xec","\x4d"),
	HX_HCSTRING("vertexShader","\xa9","\xb1","\x35","\xbd"),
	HX_HCSTRING("fragmentShader","\x15","\x4f","\xdc","\x39"),
	HX_HCSTRING("geometryShader","\x77","\x47","\xf8","\x1d"),
	HX_HCSTRING("tessellationControlShader","\xe1","\x21","\x63","\x5c"),
	HX_HCSTRING("tessellationEvaluationShader","\xe2","\x94","\x02","\xa5"),
	HX_HCSTRING("cullMode","\x35","\x06","\xdd","\xb0"),
	HX_HCSTRING("depthWrite","\xdc","\x60","\xc5","\x2c"),
	HX_HCSTRING("depthMode","\x06","\x2e","\xe4","\x9e"),
	HX_HCSTRING("stencilMode","\x7f","\x6b","\x5a","\x45"),
	HX_HCSTRING("stencilBothPass","\x0e","\x44","\x39","\xda"),
	HX_HCSTRING("stencilDepthFail","\xe5","\x96","\x76","\x67"),
	HX_HCSTRING("stencilFail","\xfa","\x51","\xaf","\x40"),
	HX_HCSTRING("stencilReferenceValue","\xc2","\x1a","\x35","\x60"),
	HX_HCSTRING("stencilReadMask","\x7e","\xf1","\x2b","\xe5"),
	HX_HCSTRING("stencilWriteMask","\xcf","\xb7","\x47","\x1e"),
	HX_HCSTRING("blendSource","\x0c","\xa0","\xa3","\xe6"),
	HX_HCSTRING("blendDestination","\xbd","\xe9","\xa3","\x86"),
	HX_HCSTRING("blendOperation","\x96","\x69","\xd1","\xa2"),
	HX_HCSTRING("alphaBlendSource","\x4e","\x31","\xcd","\x89"),
	HX_HCSTRING("alphaBlendDestination","\x3b","\x89","\xba","\xf1"),
	HX_HCSTRING("alphaBlendOperation","\x94","\x8d","\xd8","\xa2"),
	HX_HCSTRING("colorWriteMaskRed","\xa9","\x16","\xc2","\xdd"),
	HX_HCSTRING("colorWriteMaskGreen","\x1b","\x52","\xa4","\x16"),
	HX_HCSTRING("colorWriteMaskBlue","\x42","\xb2","\x83","\x21"),
	HX_HCSTRING("colorWriteMaskAlpha","\xb6","\xea","\x4d","\x9e"),
	HX_HCSTRING("set_colorWriteMask","\xc5","\xf2","\xff","\x30"),
	::String(null()) };

static void PipelineStateBase_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(PipelineStateBase_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void PipelineStateBase_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(PipelineStateBase_obj::__mClass,"__mClass");
};

#endif

hx::Class PipelineStateBase_obj::__mClass;

void PipelineStateBase_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("kha.graphics4.PipelineStateBase","\x31","\xa3","\xca","\x40");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = PipelineStateBase_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(PipelineStateBase_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< PipelineStateBase_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = PipelineStateBase_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PipelineStateBase_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PipelineStateBase_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace kha
} // end namespace graphics4
